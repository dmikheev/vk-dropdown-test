# VK dropdown
> Дропдаун для ВКонтакте

![Demo screenshot](https://raw.githubusercontent.com/dmikheev/vk-dropdown-test/master/demo.PNG)

## Что реализовано:
* За основу для вёрстки взят дизайн имеющегося дропдауна ВК.
* Добавлен лоадер для индикации загрузки, если клиентский поиск не нашёл ни одного результата.
* При инциализации дропдауна можно задать в параметрах возможность выбора одного или нескольких пользователей и отключить показ аватарок.
* Список друзей скроллится без лагов в современных браузерах.
* Работает в IE10 и Opera 12.
* Поиск выполняется во всех требуемых вариантах (просто строка, строка с неправильным языком ввода, транслит, транслит с неправильным языком).
* При изменении строки поиска сначала проверяется, есть ли выполненный ранее ответ от сервера по этой строке в кеше, затем выполняется клиентская фильтрация по части пользователей и с сервера запрашивается полный поиск.
* При вводе стоит задержка на запрос (debounce) 200мс, чтобы не отправлять много лишних запросов.
* Если нужно отправить новый запрос, а в это время ещё активен старый, у него вызывается метод XMLHTTPRequest.abort().
* Когда список пользователей подходит к концу, с сервера запрашивается новая порция данных.
* Не используются никакие библиотеки (кроме инструментов сборки - Webpack, Babel, CSS-Modules).

## Содержание
- [Требования](#%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
- [Запуск демо](#%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA-%D0%B4%D0%B5%D0%BC%D0%BE)
- [Использование](#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
- [API](#api)
- [Особенности реализации](#%D0%BE%D1%81%D0%BE%D0%B1%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8)
  - [Список пользователей](#%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA-%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D0%B5%D0%B9)
  - [Кеширование данных](#%D0%BA%D0%B5%D1%88%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)
  - [Взаимодействие с сервером](#%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D0%B5-%D1%81-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%BE%D0%BC)
- [Возможные улучшения](#%D0%B2%D0%BE%D0%B7%D0%BC%D0%BE%D0%B6%D0%BD%D1%8B%D0%B5-%D1%83%D0%BB%D1%83%D1%87%D1%88%D0%B5%D0%BD%D0%B8%D1%8F)
  
## Требования

Для запуска сервера и сборки клиентского кода нужно иметь Node.js. Я при разработке использовал 10 версию, но по идее должна подойти любая версия >= 6.11.5.
  
## Запуск демо

Чтобы запустить демо, нужно сделать следующее:

* Сделать `git clone` этого репозитория
* Перейти в папку с сервером `cd server`
* Установить зависимости `npm install`
* Запустить сервер `npm start`
* Перейти в папку с клиентским кодом `cd ../client`
* Установить зависимости `npm install`
* Собрать бандл `npm run build` (Собранный код будет лежать в папке `client/dist`)
* Открыть в браузере файл `example/example.html`

## Использование

Чтобы использовать дропдаун на своей странице, нужно сделать следующее:

* Подключить файл стилей (`client/dist/main.css`)
* Подключить js (`client/dist/main.bundle.js`)
* Создать инстанс дропдауна, вызвав `new VkTestDropdown()` с необходимыми [параметрами](#constructorelement-options).

## API

### `constructor(element, options)`

Создаёт экземпляр дропдауна с соответствующими параметрами, отрисовывая его в переданном DOM-элементе.

```
/**
 * @param {HTMLElement} element - элемент, в котором нужно отрисовать дропдаун
 * @param {DropdownMainOptions} options
 */

/**
 * @typedef {Object} DropdownMainOptions
 * @property {boolean} [areUserPhotosDisabled=false] - true, если нужно отключить показ аватаров пользователей
 * @property {boolean} [isSelectionMultiple=false] - true, если можно выбирать несколько пользователей
 * @property {User[]} initialUsers - начальные данные пользователей
 * @property {UserLoadConfig} usersLoadConfig - параметры загрузки пользователей
 */

/**
 * @typedef {Object} User
 * @property {number} id
 * @property {string} name
 * @property {string} lastName
 * @property {string} domain
 * @property {string} photoPath
 * @property {string} occupation
 */
 
/**
 * @typedef {Object} UserLoadConfig
 * @property {string} [method=GET]
 * @property {string} url
 */
```

Подразумевается, что в initialUsers передаются первые 1000 пользователей.

### `getSelectedUserIds()`

Возвращает массив id выбранных пользователей

```
/**
 * @return {number[]}
 */
```

### `getSelectedUsers()`

Возвращает объекты с данными выбранных пользователей

```
/**
 * @return {User[]}
 */
```

## Особенности реализации
### Список пользователей

Чтобы улучшить производительность, в списке реально отрисовывается только 11 элементов пользователей.
Во время скролла элементы, которые двигаются от области, видимой пользователю, удаляются из DOM и элементы с новыми пользователями
добавляются к списку с другой стороны. Чтобы уменьшить время перерисовки браузером, все элементы списка позиционированы абсолютно и
их координаты задаются с помощью transform.

### Кеширование данных

Чтобы не запрашивать одни и те же данные, id пользователей из результатов запросов сохраняются.
Также, если была подгружена новая порция пользователей, они добавляются в кеш в соответствии с текстом поиска.

### Взаимодействие с сервером

Возможна ситуация, когда мы получаем ответ от сервера очень поздно, когда строка поиска уже изменилась.
Чтобы в таком случае не добавлять устаревшие данные в список, сервер в ответе присылает параметры, с которыми был отправлен запрос.
На сервере реализован единственный GET-метод `/api/users/search`, который принимает 2 параметра: `query` - со строкой поиска, 
и `offset` - со значением, на которое надо сместить результаты поиска. За раз сервер возвращает максимум 1000 пользователей.

## Возможные улучшения

- Отрисовывать лоадер в конце списка, когда выполняется любой запрос данных пользователей. Сейчас лоадер рисуется,
только пока идёт запрос после фильтрации, если клиентский поиск не нашёл ни одного подходящего пользователя.
- Сделать навигацию по списку с клавиатуры и закрытие списка по нажатию на Esc.
- Подсвечивать в компоненте пользователя результат клиентского поиска.
- Кроссбраузерная стилизация скроллбара.
- Оптимизация скролла - сейчас основные тормоза в работе скролла - из-за подгрузки при быстрой прокрутке огромного количества картинок
для аватарок пользователей (с отключенными аватарками работает намного лучше). Можно было бы написать модуль, оптимизирующий
подгрузку аватарок. Также, возможно, получится ещё немного ускорить работу скролла, если не добавлять и удалять элементы при прокрутке,
а переиспользовать изначальный набор элементов, только меняя их содержимое.
